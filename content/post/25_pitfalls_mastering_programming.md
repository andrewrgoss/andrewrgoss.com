---
author: "Andrew Goss"
title: "25 Potential Pitfalls In Mastering Programming"
date: "2017-11-11"
tags:
  - "career management"
  - "programming"
---
<sub><i>written by <a href="http://programmingzen.com/author/antonio-cangiano" target="_blank">Antonio Cangiano</a></i></sub>

> I wanted to share this post as it really resonated with me. I've encountered many of these at times during my coding journey and plan to reread this.

I'm going to share with you what I see as "25" common pitfalls when learning to program (or working towards mastering programming). Many of these points affect both beginners and professionals alike â€” myself very much included.

0. Forgetting that <b>programming is all about people</b>. Yes, the machine will execute your code, but programming is solving problems for people, translating their requirements into code that will be read, maintained, and modified by other people (or yourself down the line).

1. <b>Not spending enough time programming</b>. Depending on your job or schedule, you might spend a lot of time on tasks that are related to programming but aren't actually programming itself.

2. <b>Stopping at the surface</b> of a given technology you're learning. Feeling satisfied with having mastered the basics just enough to get stuff done, without ever exploring further or going behind the scenes all that much.

3. <b>The Magpie approach</b> to learning programming. You start learning Rails, half-way through you realize that Phoenix is out there, oh and you need to learn JavaScript so you might as well go with Node.js... but wait <a href="https://medium.com/@tjholowaychuk/farewell-node-js-4ba9e7f3e52b" target="_blank">TJ switched to Go</a>, and hold on... what about Rust? Soon enough your browser history will have, "web development or data science career", "is Clojure dead?", "Clojure vs Elixir", "is Crystal mature enough", "any good frameworks for Golang", "Phoenix vs Buffalo" and "Kotlin for web development" all in the same week. ðŸ˜€

4. Reading books and watching courses online but <b>not practicing the skills</b> presented, therefore quickly forgetting about them.

5. <b>Skipping fundamentals</b>. So you end up learning about continuation-passing style (CPS) but still can't do SQL joins without an object-relational mapper.

6. <b>Not enough patience or discipline</b> to progress through the learning process and steps required to master any technology.

7. <b>No clear map or schedule for continuing to learn</b> through available resources, while you tackle more immediate challenges in your day-to-day programming.

8. <b>Analysis paralysis</b>, wasting way too much time choosing amongst various frameworks and libraries (like Angular, React, and Vue), rather than just picking one, using it, and switching to something else only if you actually need to do so. Basically being a maximizer instead of a satisficer.

9. Refusing the polyglot nature of modern-day programming. In most domains, it isn't reasonable to expect one programming language to be the best fit for every problem. Likewise, <b>identifying too much as an X or Y programmer</b>, rather than just a programmer who prefers X or Y.

10. <b>Fear of experimenting with new technology</b>. Rather than just reading about certain emerging technologies (e.g., blockchain or chatbots), actually firing up a VM to try them out yourself, even if it involves getting your hands dirty with a programming language or API you are not familiar with.

11. <b>Expecting to know everything upfront</b>. Being disappointed after finding pointers to the solution via Google, because you didn't come up with an elegant solution entirely on your own and kicking yourself while thinking, "I should have thought of that myself".

12. <b>Not creating many small katas</b>, exercises, and projects while learning.

13. <b>Fear of sharing code</b> with others or getting code reviews, lest you be judged.

14. <b>Not seeking one-on-one mentorship</b> from more experienced developers.

15. Expecting to learn everything at once with <b>unrealistic timelines</b> (e.g., master iOS development in a month).

16. For the more entrepreneur-minded, <b>not exploring cool projects because they don't have a clear path to revenue generation</b>.

17. Not asking questions for <b>fear of coming across as stupid</b> or as more of a newbie than you actually are.

18. Feeling like you are not a real programmer if you're creating apps by gluing high-level libraries together, in a high-level language instead of doing "hardcore" algorithms in more complex languages. I dub this <b>low-level programming envy</b>.

19. <b>Allowing the desire to learn best practices to hinder your ability to grasp the fundamentals</b> of a given language or technology. For example, feeling like you need to learn a whole book on design patterns or master TDD/BDD before you start creating projects.

20. Perfectionism. <b>Letting perfect be the enemy of good enough</b>. Never shipping anything, getting stuck in the "final touches" phase. (But balance is important, so don't ship horribly broken software for the sake of shipping.)

21. Related to the previous point, <b>ignoring the progression: make it work, make it faster, make it clean</b>. Instead, expecting a polished solution from the get-go. It's important to accept that the first iteration will be a rough draft to improve upon.

22. <b>Impostor Syndrome</b>. Feeling that you aren't good enough. This is particularly bad if you don't fit the current developer stereotype, as a lack of role models that you can relate with might mistakenly confirm your doubts. This is part of why women and minorities representation in tech is so key.

23. Writing code and learning about programming from books, but <b>never reading other people's code</b>. Open Source gives us an amazing resource that can drastically speed up our understanding of programming and best practices.

24. <b>Not getting exposed to other paradigms or domains</b>. If you're a web developer, not learning about other types of development. If you know Object-Oriented programming, not learning about Functional programming.

25. <b>Not teaching others what you learn</b>. Nothing will solidify what you learn as well as trying to explain it to others. Even just studying with the intention of teaching will increase your ability to learn.

There you have it... 25 pitfalls. Oh, don't forget off-by-one errors, too. ðŸ˜€

### Conclusion

All this to say:

> You're good enough. You can definitely do it. Just watch out for these pitfalls, make a plan, commit to it, then take it one step at the time.

When learning to program (or improving your current mastery of it), I recommend the code/read/teach method. Code one real project, and many small exercises/katas as you learn. Read books but also other people's code. Finally, teach what you learn online and in person. You don't need to be an expert to do so.

<img src="https://i0.wp.com/programmingzen.com/wp-content/uploads/2017/11/learning-to-program.gif?zoom=1.25&resize=692%2C267"><br><br>

<a href="http://programmingzen.com/pitfalls-when-learning-to-program" class="btn" target="_blank">View original article</a>

<sub>*Source: <a href="http://programmingzen.com" target=_>Programming Zen</a></sub>